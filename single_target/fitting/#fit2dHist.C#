//
//+   Example to fit two histograms at the same time via TVirtualFitter
//
// To execute this tutorial, you can do:
//
// root > .x fit2dHist.C  (executing via CINT, slow)
//   or
// root > .x fit2dHist.C+     (executing via ACLIC , fast, with Minuit)
// root > .x fit2dHist.C+(2)  (executing via ACLIC , fast, with Minuit2)
//   or using the option to fit independently the 2 histos
// root > .x fit2dHist.C+(10) (via ACLIC, fast, independent fits with Minuit)
// root > .x fit2dHist.C+(12) (via ACLIC, fast, independent fits with Minuit2)
//
// Note that you can also execute this script in batch with eg,
//  root -b -q "fit2dHist.C+(12)"
//
// or execute interactively from the shell
//  root fit2dHist.C+
//  root "fit2dHist.C+(12)"
//
// Authors: Lorenzo Moneta, Rene Brun 18/01/2006   

#include "TH2D.h"
#include "TF2.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TRandom3.h"
#include "TVirtualFitter.h"
#include "TList.h"
#include "TFile.h"
#include "TROOT.h"
#include "TMath.h"
#include "TMinuit.h"
#include <vector>
#include <iostream>

//______Load Hists__________
#include<settings.C>

Double_t fglobal_chi2;
Double_t fglobal_nbins;

TH1F *hExp1st,*hExp1st_mult1, *hExp1st_2nCut, *hExpLow_mult2, *hExpHigh_mult2, *hExpLow_2nCut, *hExpHigh_2nCut, *hExp3body_mult2, *hExp3body_2nCut;
TH1F *hExpMult,*hExpVrel;

TH1F *hSim1st[components],*hSim1st_mult1[components], *hSim1st_2nCut[components], *hSimLow_mult2[components], *hSimHigh_mult2[components], *hSimLow_2nCut[components], *hSimHigh_2nCut[components], *hSim3body_mult2[components], *hSim3body_2nCut[components];
TH1F *hSimMult[components],*hSimVrel[components];

TH1F *h1SimInput, *h5SimInput;

Double_t fRebin = 4;
Double_t fScale[components];
Double_t fErrors[components][2];
Double_t fit_min=0, fit_max=999;

Double_t fExpWidth=0, fSimWidth=0;
Double_t fExpWidth2=0, fSimWidth2=0;
Bool_t kR[components];

TFile *fin[components];

//vector<double> params[components][4];
/*for (int i=0;i<components;i++)
{
	fin[i] = 0;
	fScale[i] = 0;
}*/

//__________________________________________
void GetSimHists(Int_t NN, TString filename=""){

  NN = NN - 1; //to correct for indices all beginning at zero. - JKS

    if(fin[NN]) fin[NN]->Close();
    fin[NN] = new TFile(filename, "READ");

    TH1F *tempH1 = (TH1F*) fin[NN]->Get("hGEdecay1st_only");
    TH1F *tempH2 = (TH1F*) fin[NN]->Get("hGEdecay1st_only_mult1");
    TH1F *tempH3 = (TH1F*) fin[NN]->Get("hGEdecay1st_only_2nCut");

    TH1F *tempH4 = (TH1F*) fin[NN]->Get("hGEdecayHigh_mult2");
    TH1F *tempH5 = (TH1F*) fin[NN]->Get("hGEdecayLow_mult2");
    TH1F *tempH6 = (TH1F*) fin[NN]->Get("hGEdecayHigh_2nCut");
    TH1F *tempH7 = (TH1F*) fin[NN]->Get("hGEdecayLow_2nCut");

    TH1F *tempH8 = (TH1F*) fin[NN]->Get("hGEdecay3body_mult2");
    TH1F *tempH9 = (TH1F*) fin[NN]->Get("hGEdecay3body_2nCut");

    TH1F *tempH18 = (TH1F*) fin[NN]->Get("hMult");

    //TH1F *tempInput = (TH1F*) fin1->Get("hInput3body");
    //h1SimInput = (TH1F*) tempInput->Clone("h1SimInput");

    hSimMult[NN] = (TH1F*) tempH18->Clone("h1SimMult");

    hSim1st[NN] = (TH1F*) tempH1->Clone("h1Sim1st");
    hSim1st_mult1[NN] = (TH1F*) tempH2->Clone("h1Sim1st_mult1");
    hSim1st_2nCut[NN] = (TH1F*) tempH3->Clone("h1Sim1st_2nCut");

    hSimHigh_mult2[NN] = (TH1F*) tempH4->Clone("h1SimHigh_mult2");
    hSimLow_mult2[NN] = (TH1F*) tempH5->Clone("h1SimLow_mult2");
    hSimHigh_2nCut[NN] = (TH1F*) tempH6->Clone("h1SimHigh_2nCut");
    hSimLow_2nCut[NN] = (TH1F*) tempH7->Clone("h1SimLow_2nCut");

    hSim3body_mult2[NN] = (TH1F*) tempH8->Clone("h1Sim3body_mult2");
    hSim3body_2nCut[NN] = (TH1F*) tempH9->Clone("h1Sim3body_2nCut");
    
    hSim1st[NN]->Rebin(fRebin);
    hSim1st_mult1[NN]->Rebin(fRebin);
    hSim1st_2nCut[NN]->Rebin(fRebin);
    hSimHigh_mult2[NN]->Rebin(fRebin);
    hSimLow_mult2[NN]->Rebin(fRebin);
    hSimHigh_2nCut[NN]->Rebin(fRebin);
    hSimLow_2nCut[NN]->Rebin(fRebin);
    hSim3body_mult2[NN]->Rebin(fRebin);
    hSim3body_2nCut[NN]->Rebin(fRebin);  


    cout << "Sim BinWidth: " << hSim1st[NN]->GetBinWidth(2) << endl;

  cout << "Finished accessing sim root files" << endl;
}


void AssignExpHists(TObjArray* exp_array)
{
//	cout <<"Experimental array length: " <<exp_array->GetSize() <<endl;
	hExp1st = (TH1F*) exp_array->At(0);
//	hExpVrel = (TH1F*) exp_array->At(1);
	// 10Be edit: uncomment next three lines
//	hExp1st_mult1 = (TH1F*) exp_array->At(1);
//	hExp3body_mult2 = (TH1F*) exp_array->At(2);
//	Exp3body_2nCut = (TH1F*) exp_array->At(3);
}

void AssignSimHists(TObjArray* sim_array, vector<int> indexes)
{
	for (int i=0;i<indexes.size();i++)
	{
		hSim1st[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(0))->At(indexes[i]);
//		hSimVrel[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(1))->At(indexes[i]);
		// 10Be edit: uncomment next three lines
		hSim1st_mult1[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(2))->At(indexes[i]);
		hSim3body_mult2[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(3))->At(indexes[i]);
		hSim3body_2nCut[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(4))->At(indexes[i]);
		hSimMult[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(5))->At(indexes[i]);
	}
}

void AssignSimHists(TObjArray* sim_array,int pathnum, int* indexes)
{
	for (int i=0;i<pathnum;i++)
	{
		hSim1st[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(0))->At(indexes[i]);
		hSimVrel[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(1))->At(indexes[i]);
		// 10Be edit: uncomment next three lines
		hSim1st_mult1[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(2))->At(indexes[i]);
		hSim3body_mult2[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(3))->At(indexes[i]);
		hSim3body_2nCut[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(4))->At(indexes[i]);
		hSimMult[i] = (TH1F*) ((TObjArray*)((TObjArray*)sim_array->At(i))->At(5))->At(indexes[i]);
	}
}


//------
Double_t GetChi2(TH1F *data, TH1F* *sim_hsts, Double_t *ppar, Double_t &binCount){
  //maximum energy to fit to
  Double_t fitmax = 5;
  binCount = 0;
  Double_t chi2 = 0;
  Double_t content,bincenter,binerr,simContent;
  int endbin = TMath::Min(data->FindBin(fitmax),data->GetNbinsX());
  //loop over bins and calculate chi2
  for(int i=1; i<endbin+1; i++){

    //Get bin content, center, and error
    content = data->GetBinContent(i);
    bincenter = data->GetBinCenter(i);
    binerr = data->GetBinError(i);
//    if(content>5 && bincenter < fitmax){
//    if(content>5 && bincenter > 1.0){
    if(content>5 && bincenter<2.0){
      
    //Get simbin content
    simContent = 0;
    for (int j=0;j<components;j++)
    {
    	simContent = simContent + ppar[j]*(sim_hsts[j]->GetBinContent(i));
    }

      // Calculate \chi^2 value.
      chi2 = chi2 + TMath::Power( (content - simContent)/binerr, 2.0);
      binCount++;
      //printf("bincenter: %f  simcenter: %f  bincontent: %f  simcontent:%f par:%f chi2:%f binerr:%f\n", bincenter, htot->GetBinCenter(htot->FindBin(bincenter)), content, simContent,ppar[4],chi2,binerr);
      //for(int i=0; i<components; i++) printf("    par[%d]: %f\n",i,ppar[i]);
    }

  }

  return chi2;
}

//_____________________________________________________________________________
void zfcn(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag) {
//  cout << "HERE" << endl;
  //for(int i=0; i<npar; i++) printf("  --par[%d]:%f\n",i,par[i]);
  
  Bool_t kDraw = false;
// 10Be edit: change to 4
  const int hsts2fit = 4; //number of histograms you would like to fit.

  Double_t ppar[components];
  for (int i=0;i<components;i++)
  	ppar[i] = par[i];
  Double_t bins[hsts2fit];
  Double_t errors[hsts2fit];
  Double_t events[hsts2fit];


//  cout << "HERE1" << endl;
  // Not looping this because I'm not sure how to properly loop it through the
  // desired histograms at the moment. -JKS, 29 April 2013
  //----1st Fit-----
  errors[0] = GetChi2(hExp1st, hSim1st, ppar, bins[0]);    
  events[0] = hExp1st->GetEntries();
  //-----2nd Fit-----
//  errors[1] = GetChi2(hExpVrel, hSimVrel, ppar, bins[1]);  
//  events[1] = hExpVrel->GetEntries();

// 10Be edit: uncomment next three fits
  //-----2nd Fit-----
//  errors[1] = GetChi2(hExp1st_mult1, hSim1st_mult1, ppar, bins[1]);  
//  events[1] = hExp1st_mult1->GetEntries();
/*
  //----3rd Fit--------
  errors[2] = GetChi2(hExp3body_mult2, hSim3body_mult2, ppar, bins[2]);    
  events[2] = hExp3body_mult2->GetEntries();

  //----4th Fit--------
  errors[3] = GetChi2(hExp3body_2nCut, hSim3body_2nCut, ppar, bins[3]);
  events[3] = hExp3body_2nCut->GetEntries();
*/
//  cout << "HERE3" << endl;
  Double_t ERROR=0;
//  cout << "HERE4" << endl;
  fglobal_nbins = 0;
  for (int i=0;i<hsts2fit;i++)
  {
//  	cout <<"inside." <<endl;
  	ERROR = ERROR + errors[i];
	fglobal_nbins = fglobal_nbins + bins[i];
  }

  fglobal_chi2 = ERROR;

  f = ERROR;
}
//_____________________________________________________



double fit2dHist_Run(int option=11) { 

  // create two histograms 
  bool global = false;
  if (option > 10) global = true;
  if (global) { 
    // fill data structure for fit (coordinates + values + errors) 
//    std::cout << "Do global fit" << std::endl;
    // fit now all the function together

    //The default minimizer is Minuit, you can also try Minuit2
    if (option%10 == 2) TVirtualFitter::SetDefaultFitter("Minuit2");
    else                TVirtualFitter::SetDefaultFitter("Minuit");
    //Create the fitter. Second argument is maximum number of parameters. The first parameter is a pointer to the object being fit?
    TVirtualFitter * minuit = TVirtualFitter::Fitter(0,components);  

    double arglist[100];
    arglist[0] = -1;
    arglist[1] = -1;
    // set print level
    minuit->ExecuteCommand("SET PRINT",arglist,2);
    minuit->ExecuteCommand("SET NOWARNINGS",arglist,1);
    //starting weights for each of the seven histograms
    Double_t vstart[components];
    for (int i = 0; i < components; ++i) {  
      vstart[i] = 0.5;
      TString name = Form("param_scale_%d",i);
      minuit->SetParameter(i, name, vstart[i], 0.001, 0.000001,10);
    }
//      minuit->SetParameter(1, "param_scale_1", 0, 0.001, 0.00001,10);
//      minuit->FixParameter(1);

	//set minimization function (\chi^2)
    minuit->SetFCN(zfcn);

    //Chi2 (1), LogLike (0.5)
    //sets error level to 1 sigma
    //This is Q_\gamma. Minuit will calculate errors as parameter values which satisfy
    //\chi^2=\chi^2_{min}+Q_\gamma.
    double chi2quantile = TMath::ChisquareQuantile(0.682689492,ndf);
    minuit->SetErrorDef(chi2quantile);

    // minimize
    arglist[0] = 10000; // number of function calls
    arglist[1] = 0.01; // tolerance
    //what do these do? why choose one over the other?
    //minuit->ExecuteCommand("MINImize",arglist,2);
    //minuit->ExecuteCommand("SIMPLEX",arglist,2);
    minuit->ExecuteCommand("MIGRAD",arglist,2);
    if (asymErrors) minuit->ExecuteCommand("MINOS",arglist,0);
    // this lets us look at the errors up to an arbitrary chi^2 limit, chi2limit
    // if you just want 1 sigma errors, set chi2limit to zero.

    //cout << "DONE" << endl;
    //get result
    double minParams[components];
    // for MINOS, make this an array
    double MinosparErrors[components][4];
    double parErrors[components];
    if (option==13)
    {
    	for (int i = 0; i < components; ++i) {  
	      minParams[i] = minuit->GetParameter(i);
	      fScale[i] = minParams[i];
	      if (asymErrors)
	      {
		    if (fglobal_chi2<chi2limit)
		    {
			arglist[0] = chi2limit-fglobal_chi2;
			minuit->ExecuteCommand("SET ERR",arglist,1);
		    }
		    minuit->ExecuteCommand("MINOS",arglist,0);
		    minuit->GetErrors(i,MinosparErrors[i][0],MinosparErrors[i][1],MinosparErrors[i][2],MinosparErrors[i][3]);
	      	    cout << "  --Par " << i << "  " << minParams[i] <<", positive error: " <<MinosparErrors[i][0] <<", negative errors: " <<MinosparErrors[i][1]  <<endl;
		    //re-do fit so that fglobal_chi2 is good
		    arglist[0] = 10000; // number of function calls
		    minuit->ExecuteCommand("MIGRAD",arglist,2);
	      }
	      else
	      {
	      		parErrors[i] = minuit->GetParError(i);
	      		cout << "  --Par " << i << "  " << minParams[i] <<", error: " <<parErrors[i]  <<", percent error: " <<parErrors[i]/minParams[i] <<endl;
	      }
	    }
    }
    else
    {
    	for (int i = 0; i < components; ++i) {  
	      minParams[i] = minuit->GetParameter(i);
	      fScale[i] = minParams[i];
	      if (asymErrors)
	      {
    			if (fglobal_chi2<chi2limit)
			{
				arglist[0] = chi2limit-fglobal_chi2;
				minuit->ExecuteCommand("SET ERR",arglist,1);
			}
			minuit->ExecuteCommand("MINOS",arglist,0);
		        minuit->GetErrors(i,MinosparErrors[i][0],MinosparErrors[i][1],MinosparErrors[i][2],MinosparErrors[i][3]);
	      		fErrors[i][0] = MinosparErrors[i][0];
		      	fErrors[i][1] = MinosparErrors[i][1];
		        //re-do fit so that fglobal_chi2 is good
		    	arglist[0] = 10000; // number of function calls
		    	minuit->ExecuteCommand("MIGRAD",arglist,2);
	      }
	    }
    }

    double chi2, edm, errdef; 
    int nvpar, nparx;
    minuit->GetStats(chi2,edm,errdef,nvpar,nparx);
    minuit->Delete();

    // func->SetParameters(minParams);
    //func->SetParErrors(parErrors);
    //func->SetChisquare(chi2);
    //int ndf = npfits-nvpar;
    //func->SetNDF(ndf);

    // add to list of functions
    //h1->GetListOfFunctions()->Add(func);
    //h2->GetListOfFunctions()->Add(func);
  }
  else {     
    // fit independently
    //h1->Fit(func);
    //h2->Fit(func);
  }	     


if (option==13)
  cout << "Global chi2: " << fglobal_chi2 << "  NBINS: " << fglobal_nbins << endl;

  return fglobal_chi2; 

}




void fit2dHist(int option=11){

  TH1::SetDefaultSumw2();
  for (int i=1;i<=components;i++)
  {
  	GetSimHists(i);
  }

  gROOT->ProcessLine(".L LoadDrawFuncs.C");

  fit2dHist_Run(option);

  //DrawBestEdecay();

}



